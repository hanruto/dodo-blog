{"ast":null,"code":"const titleRegs = [{\n  type: 'h1',\n  reg: /^# .*$/\n}, {\n  type: 'h2',\n  reg: /^## .*$/\n}, {\n  type: 'h3',\n  reg: /^### .*$/\n}, {\n  type: 'h4',\n  reg: /^#### .*$/\n}];\nconst hrefReg = /\\[(?<text>.*?)\\](?<isNewTarget>[-+])\\((?<href>.*?)\\)/g;\nexport function getLetters(content) {\n  return content.split('\\n').filter(line => line !== '').map(line => {\n    for (let i = 0; i < titleRegs.length; i++) {\n      if (titleRegs[i].reg.test(line)) {\n        return {\n          type: titleRegs[i].type,\n          content: line.replace(/#+ /, '').trim()\n        };\n      }\n    }\n\n    return {\n      type: 'p',\n      content: line\n    };\n  }).map(line => {\n    let {\n      content,\n      type\n    } = line;\n    const hrefInfoArr = [];\n    let blockIndex = 0;\n    content = content.replace(hrefReg, (matched, text, targetSign, href, searchIndex) => {\n      hrefInfoArr.push({\n        start: searchIndex - blockIndex,\n        end: searchIndex + text.length - 1 - blockIndex,\n        href,\n        text,\n        targetSign\n      });\n      blockIndex += matched.length - text.length;\n      return text;\n    });\n    return content.split('').map((item, index) => {\n      let isHrefStart = false;\n      let isHrefEnd = false;\n      let hrefValue = '';\n      let isNewTarget = false;\n      hrefInfoArr.forEach(({\n        start,\n        end,\n        href,\n        targetSign\n      }) => {\n        if (index === start) isHrefStart = true;\n        if (index === end) isHrefEnd = true;\n\n        if (index >= start && index <= end) {\n          hrefValue = href;\n          isNewTarget = targetSign === '+';\n        }\n      });\n      return {\n        href: hrefValue,\n        isHrefStart,\n        isHrefEnd,\n        isNewTarget,\n        type,\n        isStart: index === 0,\n        content: item,\n        isEnd: index === content.length - 1\n      };\n    });\n  }) //@ts-ignore\n  .flat();\n}","map":null,"metadata":{},"sourceType":"module"}