{"ast":null,"code":"const titleRegs = [{\n  type: 'h1',\n  reg: /^# .*$/\n}, {\n  type: 'h2',\n  reg: /^## .*$/\n}, {\n  type: 'h3',\n  reg: /^### .*$/\n}, {\n  type: 'h4',\n  reg: /^#### .*$/\n}];\nconst hrefReg = /\\[(?<text>.*?)\\](?<isNewTarget>[-+])\\((?<href>.*?)\\)/g;\nexport function getLetters(content) {\n  return content.split('\\n').filter(line => line !== '').map(line => {\n    for (let i = 0; i < titleRegs.length; i++) {\n      if (titleRegs[i].reg.test(line)) {\n        return {\n          type: titleRegs[i].type,\n          content: line.replace(/#+ /, '').trim()\n        };\n      }\n    }\n\n    return {\n      type: 'p',\n      content: line\n    };\n  }).map(line => {\n    let {\n      content,\n      type\n    } = line;\n    const hrefInfoArr = [];\n    let blockIndex = 0;\n    content = content.replace(hrefReg, (matched, text, targetSign, href, searchIndex) => {\n      hrefInfoArr.push({\n        start: searchIndex - blockIndex,\n        end: searchIndex + text.length - 1 - blockIndex,\n        href,\n        text,\n        targetSign\n      });\n      blockIndex += matched.length - text.length;\n      return text;\n    });\n    return content.split('').map((item, index) => {\n      let isHrefStart = false;\n      let isHrefEnd = false;\n      let hrefValue = '';\n      let isNewTarget = false;\n      hrefInfoArr.forEach(({\n        start,\n        end,\n        href,\n        targetSign\n      }) => {\n        if (index === start) isHrefStart = true;\n        if (index === end) isHrefEnd = true;\n\n        if (index >= start && index <= end) {\n          hrefValue = href;\n          isNewTarget = targetSign === '+';\n        }\n      });\n      return {\n        href: hrefValue,\n        isHrefStart,\n        isHrefEnd,\n        isNewTarget,\n        type,\n        isStart: index === 0,\n        content: item,\n        isEnd: index === content.length - 1\n      };\n    });\n  }) //@ts-ignore\n  .flat();\n}","map":{"version":3,"sources":["/Users/qm/project/dodo-blog-v2/utils/string-tools.tsx"],"names":["titleRegs","type","reg","hrefReg","getLetters","content","split","filter","line","map","i","length","test","replace","trim","hrefInfoArr","blockIndex","matched","text","targetSign","href","searchIndex","push","start","end","item","index","isHrefStart","isHrefEnd","hrefValue","isNewTarget","forEach","isStart","isEnd","flat"],"mappings":"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","sourcesContent":["const titleRegs = [\n  { type: 'h1', reg: /^# .*$/ },\n  { type: 'h2', reg: /^## .*$/ },\n  { type: 'h3', reg: /^### .*$/ },\n  { type: 'h4', reg: /^#### .*$/ },\n]\n\nconst hrefReg = /\\[(?<text>.*?)\\](?<isNewTarget>[-+])\\((?<href>.*?)\\)/g\n\nexport function getLetters(content: string) {\n  return (\n    content\n      .split('\\n')\n      .filter(line => line !== '')\n      .map(line => {\n        for (let i = 0; i < titleRegs.length; i++) {\n          if (titleRegs[i].reg.test(line)) {\n            return {\n              type: titleRegs[i].type,\n              content: line.replace(/#+ /, '').trim(),\n            }\n          }\n        }\n\n        return { type: 'p', content: line }\n      })\n      .map(line => {\n        let { content, type } = line\n        const hrefInfoArr: {\n          start: number\n          end: number\n          href: string\n          text: string\n          targetSign: string\n        }[] = []\n        let blockIndex = 0\n\n        content = content.replace(\n          hrefReg,\n          (matched, text, targetSign, href, searchIndex) => {\n            hrefInfoArr.push({\n              start: searchIndex - blockIndex,\n              end: searchIndex + text.length - 1 - blockIndex,\n              href,\n              text,\n              targetSign,\n            })\n\n            blockIndex += matched.length - text.length\n            return text\n          }\n        )\n\n        return content.split('').map((item, index) => {\n          let isHrefStart = false\n          let isHrefEnd = false\n          let hrefValue: string = ''\n          let isNewTarget = false\n\n          hrefInfoArr.forEach(({ start, end, href, targetSign }) => {\n            if (index === start) isHrefStart = true\n            if (index === end) isHrefEnd = true\n            if (index >= start && index <= end) {\n              hrefValue = href\n              isNewTarget = targetSign === '+'\n            }\n          })\n\n          return {\n            href: hrefValue,\n            isHrefStart,\n            isHrefEnd,\n            isNewTarget,\n            type,\n            isStart: index === 0,\n            content: item,\n            isEnd: index === content.length - 1,\n          }\n        })\n      })\n      //@ts-ignore\n      .flat()\n  )\n}\n"]},"metadata":{},"sourceType":"module"}