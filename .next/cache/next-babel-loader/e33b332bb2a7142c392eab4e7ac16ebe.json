{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Symbol$replace from \"@babel/runtime-corejs2/core-js/symbol/replace\";\nimport _WeakMap from \"@babel/runtime-corejs2/core-js/weak-map\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime-corejs2/helpers/esm/wrapNativeSuper\";\n\nfunction _wrapRegExp(re, groups) { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = _wrapNativeSuper(RegExp); var _super = RegExp.prototype; var _groups = new _WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } _inherits(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[_Symbol$replace] = function (str, substitution) { if (typeof substitution === \"string\") { var groups = _groups.get(this); return _super[_Symbol$replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) { return \"$\" + groups[name]; })); } else if (typeof substitution === \"function\") { var _this = this; return _super[_Symbol$replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (typeof args[args.length - 1] !== \"object\") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[_Symbol$replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return _Object$keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, _Object$create(null)); } return _wrapRegExp.apply(this, arguments); }\n\nvar titleRegs = [{\n  type: 'h1',\n  reg: /^# .*$/\n}, {\n  type: 'h2',\n  reg: /^## .*$/\n}, {\n  type: 'h3',\n  reg: /^### .*$/\n}, {\n  type: 'h4',\n  reg: /^#### .*$/\n}];\n\nvar hrefReg = _wrapRegExp(/\\[(.*?)\\]([\\+\\x2D])\\((.*?)\\)/g, {\n  text: 1,\n  isNewTarget: 2,\n  href: 3\n});\n\nexport function getLetters(content) {\n  return content.split('\\n').filter(function (line) {\n    return line !== '';\n  }).map(function (line) {\n    for (var i = 0; i < titleRegs.length; i++) {\n      if (titleRegs[i].reg.test(line)) {\n        return {\n          type: titleRegs[i].type,\n          content: line.replace(/#+ /, '').trim()\n        };\n      }\n    }\n\n    return {\n      type: 'p',\n      content: line\n    };\n  }).map(function (line) {\n    var content = line.content,\n        type = line.type;\n    var hrefInfoArr = [];\n    var blockIndex = 0;\n    content = content.replace(hrefReg, function (matched, text, targetSign, href, searchIndex) {\n      hrefInfoArr.push({\n        start: searchIndex - blockIndex,\n        end: searchIndex + text.length - 1 - blockIndex,\n        href: href,\n        text: text,\n        targetSign: targetSign\n      });\n      blockIndex += matched.length - text.length;\n      return text;\n    });\n    return content.split('').map(function (item, index) {\n      var isHrefStart = false;\n      var isHrefEnd = false;\n      var hrefValue = '';\n      var isNewTarget = false;\n      hrefInfoArr.forEach(function (_ref) {\n        var start = _ref.start,\n            end = _ref.end,\n            href = _ref.href,\n            targetSign = _ref.targetSign;\n        if (index === start) isHrefStart = true;\n        if (index === end) isHrefEnd = true;\n\n        if (index >= start && index <= end) {\n          hrefValue = href;\n          isNewTarget = targetSign === '+';\n        }\n      });\n      return {\n        href: hrefValue,\n        isHrefStart: isHrefStart,\n        isHrefEnd: isHrefEnd,\n        isNewTarget: isNewTarget,\n        type: type,\n        isStart: index === 0,\n        content: item,\n        isEnd: index === content.length - 1\n      };\n    });\n  }) //@ts-ignore\n  .flat();\n}","map":{"version":3,"sources":["/Users/qm/project/dodo-blog-v2/utils/string-tools.tsx"],"names":["titleRegs","type","reg","hrefReg","getLetters","content","split","filter","line","map","i","length","test","replace","trim","hrefInfoArr","blockIndex","matched","text","targetSign","href","searchIndex","push","start","end","item","index","isHrefStart","isHrefEnd","hrefValue","isNewTarget","forEach","isStart","isEnd","flat"],"mappings":"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","sourcesContent":["const titleRegs = [\n  { type: 'h1', reg: /^# .*$/ },\n  { type: 'h2', reg: /^## .*$/ },\n  { type: 'h3', reg: /^### .*$/ },\n  { type: 'h4', reg: /^#### .*$/ },\n]\n\nconst hrefReg = /\\[(?<text>.*?)\\](?<isNewTarget>[-+])\\((?<href>.*?)\\)/g\n\nexport function getLetters(content: string) {\n  return (\n    content\n      .split('\\n')\n      .filter(line => line !== '')\n      .map(line => {\n        for (let i = 0; i < titleRegs.length; i++) {\n          if (titleRegs[i].reg.test(line)) {\n            return {\n              type: titleRegs[i].type,\n              content: line.replace(/#+ /, '').trim(),\n            }\n          }\n        }\n\n        return { type: 'p', content: line }\n      })\n      .map(line => {\n        let { content, type } = line\n        const hrefInfoArr: {\n          start: number\n          end: number\n          href: string\n          text: string\n          targetSign: string\n        }[] = []\n        let blockIndex = 0\n\n        content = content.replace(\n          hrefReg,\n          (matched, text, targetSign, href, searchIndex) => {\n            hrefInfoArr.push({\n              start: searchIndex - blockIndex,\n              end: searchIndex + text.length - 1 - blockIndex,\n              href,\n              text,\n              targetSign,\n            })\n\n            blockIndex += matched.length - text.length\n            return text\n          }\n        )\n\n        return content.split('').map((item, index) => {\n          let isHrefStart = false\n          let isHrefEnd = false\n          let hrefValue: string = ''\n          let isNewTarget = false\n\n          hrefInfoArr.forEach(({ start, end, href, targetSign }) => {\n            if (index === start) isHrefStart = true\n            if (index === end) isHrefEnd = true\n            if (index >= start && index <= end) {\n              hrefValue = href\n              isNewTarget = targetSign === '+'\n            }\n          })\n\n          return {\n            href: hrefValue,\n            isHrefStart,\n            isHrefEnd,\n            isNewTarget,\n            type,\n            isStart: index === 0,\n            content: item,\n            isEnd: index === content.length - 1,\n          }\n        })\n      })\n      //@ts-ignore\n      .flat()\n  )\n}\n"]},"metadata":{},"sourceType":"module"}